{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/redux-toolkit/","result":{"data":{"markdownRemark":{"html":"<h2>리덕스 툴킷</h2>\n<p>리덕스를 사용하는데 코드가 많이 길어지는 것이 많이 불편하기 때문에, 이를 좀더 간결하게 사용하기 위한 리덕스 라이브러리 입니다.</p>\n<p>본문에서는 <code>createSlice</code> 만 이용하여 Redux에서 사용하는 <code>reducer, action, const TYPE</code> 등을 한번에 정의 하는 것을 알아볼 것 입니다.\n여기서 나오는 글은 - <a href=\"https://www.youtube.com/watch?v=9lCmbth63k0\">출처</a> 에서 본 것을 정리 하는 글 입니다.</p>\n<hr>\n<h4>리덕스</h4>\n<ul>\n<li>전역상태를 관리하기 위한 라이브러리</li>\n</ul>\n<p>리덕스는 <code>type, state, action, reducer</code> 로 이루어져 있다. </p>\n<ul>\n<li><code>type</code> : 그냥 단순한 이름이라고 생각하면 된다.\n보통 <code>const TODO_CREATE = \"TODOS/CREATE\"</code>\n이런식으로 대문자를 사용해서 정의 해준다.\n이렇게 따로 상수로 정의해주는 것은, 에디터의 자동완성을 통한 오류방지이다.</li>\n<li><code>state</code> : 전역으로 관리하고 싶은 상태</li>\n<li>\n<p><code>action</code> : <code>dispatch</code>를 통해서 보내주는 것.  </p>\n<pre><code class=\"language-ts\">dispatch({type : TODO_CREATE, data : { title : '' }})\n// 이런 식으로 객체 형식으로 생겼다. \ninterface TodoCreateActionType {\ntype : typeof SELECT_TODO;\npayload : { title : string };\n}\n</code></pre>\n</li>\n</ul>\n<p>export const todoCreateAction = ({ title } : { title : string }) : TodoCreateActionType => ({\ntype : SELECT_TODO,\npayload : { title },\n})</p>\n<pre><code>- `reducer` : `action`이 들어왔을 때 `state` 를 정의하는 곳이다.\n```ts\ntype todoActionTypes = CrateTodoActionTypes | DeleteActionType | EditTodoActionType | ToggleActionType;\n\n const todoReducer = (state : Todo[] = initialState, action : todoActionTypes) => {\n    switch(action.type) {\n        case CREATE_TODO : {\n            const { payload } = action;\n            return [...state, payload];\n        }\n        case EDIT_TODO : {\n            const { payload } = action;\n            return state.map(todo => todo.id === payload.id ? {...todo, desc : payload.desc } : todo );\n        }\n        case TOGGLE_TODO : {\n            const { payload } = action;\n            return state.map(todo => todo.id === payload.id ? {...todo, isComplete : payload.isComplete } : todo);\n        }\n        case DELETE_TODO : {\n            const { payload } = action;\n            return state.filter(todo => todo.id !== payload.id);\n        }\n        default : return state;\n    }\n}\n</code></pre>\n<p> <code>state</code>는 초기값 을 <code>필수</code>로 정의해주어야 한다.\n또한, return 값은 <code>immutable</code> 값을 갖는데,<br>\n<code>state = 1</code> 이런식으로 직접 정의 해주면 안된다. <code>state</code> 값은  <strong>action이 이루어 지기전 상태값들을 갖고 있는데 그 값을 직접 바꾸지 않고 새로운 값을 보내주어야 한다.</strong> </p>\n<hr>\n<h3>리덕스 툴킷</h3>\n<ul>\n<li>\n<p><code>createSlice</code> </p>\n<pre><code class=\"language-ts\">const exampleSlice = createSlice({\nname : 'example', // 정의하고 싶은 명칭 \ninitalState : { id }, \nreducers : { // exampleSlice.reducer 로 접근 할 수 있다.\nnewId : (state, action :PayloadAction&#x3C;{ id : string }>) => {\n  state.id = action.payload.id;\n}\n // newId => exampleSlice.actions.newId 로 접근 가능\n // newId의 type 은 exampleSlice.actions.newId.type\n}\n})\n</code></pre>\n</li>\n</ul>\n<pre><code>리덕스 툴킷 `createSlice` 의 가장 큰 특징은, reudcer를 사용할 때, `mutable`하다는 것이다. `immer` 가 내부적으로 있어서 `state = state + 1` 이런식으로 상태를 변화 할수 있다는 것이다.\n\n\n```ts\nconst todosSlice = createSlice({\n    name : 'todos',\n    initialState : todosInitialState,\n    reducers : {\n        create : {\n            reducer: (state, { payload } : PayloadAction&#x3C;{id : string; desc: string; isComplete : boolean; }>) => {\n                state.push(payload);\n            },\n            prepare: ({ desc } : { desc : string; }) => ({\n                payload : {\n                    id : uuid(),\n                    desc,\n                    isComplete : false\n                }\n            })\n        },\n        edit : (state, { payload }: PayloadAction&#x3C;{ id : string; desc : string; }>) => {\n            const todoToEdit = state.find(todo => todo.id === payload.id);\n            if(todoToEdit) todoToEdit.desc = payload.desc;\n        },\n        toggle : (state, { payload }:PayloadAction&#x3C;{ id : string; }>) => {\n            const todoToEdit = state.find(todo => todo.id === payload.id);\n            if(todoToEdit) todoToEdit.isComplete = !todoToEdit.isComplete;\n        },\n        remove : (state, { payload }:PayloadAction&#x3C;{ id : string; }> ) =>{\n            const index = state.findIndex(todo => todo.id === payload.id);\n            if(index !== -1) state.splice(index, 1);\n        }\n    }\n})\n</code></pre>\n<p><code>action</code> 안에서 <code>reducer</code>를 정의 해줄 수 있는데, 앞의 <code>create</code>의 예를 보면 <code>prepare</code> 로 상태를 변화하기 전에 먼저 <code>action</code>으로 부터 받은 값들을 바꿔서 <code>action의 reducer</code> 에게 값을 보내줄 수 있다. </p>\n<p>또한 <code>createSlice</code> 에는 <code>extraReducers</code> 가 있는데, 다른 <code>reducer</code> 에 있는 <code>type</code>을 함께 <code>공유</code>할 수 있다는 개념으로 생각된다.</p>\n<pre><code class=\"language-ts\">const counterSlice = createSlice({\n    name : 'counter',\n    initialState : 0,\n    reducers : {},\n    extraReducers : {\n        [todosSlice.actions.create.type] : state => state + 1,\n      // reducer의 return 값은 state에 정의 되기 때문에 이렇게 해도 된다\n        [todosSlice.actions.edit.type] : state => state + 1,\n        [todosSlice.actions.toggle.type] : state => state +1,\n        [todosSlice.actions.remove.type] : state => state +1,\n    }\n    // 다른 리듀서의 액션타입과 연동지어서 사용할 때.\n})\n</code></pre>\n<p>다른 리듀서의 액션타입이 들어오면 <code>counterSlice</code> 는 그 액션타입을 함께 사용해서 자신의 state들을 정의 해줄 수 있는 것이다.</p>\n<hr>\n<h3>스토어 와 사용</h3>\n<p> 상위 컴포넌트에 뿌려주기 위해서 리덕스 store 를 만들어주려면 <code>configureStore</code> 를 사용해주면 된다.</p>\n<pre><code class=\"language-ts\">import { configureStore, createSlice, getDefaultMiddleware } from '@reduxjs/toolkit';\n// const reducers = combineReducers({\n//     todos : todosSlice.reducer,\n//     selectedTodo : selectedTodoSlice.reducer,\n//     counter : counterSlice.reducer,\n// })\n// redux-toolkit을 사용하면 combine 해주지 않아도\n// 객체로 configurestore에 보내주면 알아서 해결해준다.\n\nconst reducers = {\n    todos : todosSlice.reducer,\n    selectedTodo : selectedTodoSlice.reducer,\n    counter : counterSlice.reducer,\n}\n\nexport default configureStore({\n    reducer : reducers,\n    middleware : [...getDefaultMiddleware (), logger],\n  // getDefaultMiddleware -> devTools 같은거\n    devTools : process.env.NODE_ENV !== 'production'\n})\n</code></pre>\n<p>옛날 게시물을 보면 그냥 redux의 store를 사용했는데, redux-toolkit을 사용하면 combineReducer와 devtools를 따로 사용하지 않아도 알아서 해준다.</p>\n<pre><code class=\"language-ts\">// redux-toolkit.ts\n\nexport const {\n create : createTodoActionCreator,\n edit : editTodoActionCreator,\n toggle : toggleTodoActionCreator,\n remove : deleteTodoActionCreator,\n} = todosSlice.actions;\n// export const createTodoActionCreator = todosSlice.actions.create\n// 이런식으로 createSlice로 만든 reducer의 액션들을 \n// todosSlice.actions.create로 접근해서 export 해준다. (dispatch 해주기 위해서)\n</code></pre>\n<pre><code class=\"language-tsx\">// app.tsx\n  const dispatch = useDispatch();\n  const todos = useSelector((state : State) => state.todos);\n  const editedCount = useSelector((state : State) => state.counter);\n  const selectedTodoId = useSelector((state : State) => state.selectedTodo);\n\n  const handleDelete = (): void => {\n    if (!selectedTodoId) return;\n    dispatch(deleteTodoActionCreator({ id : selectedTodoId }))\n  };\n</code></pre>\n<p>사용법은 리덕스 사용하듯이 하면 된다.</p>","frontmatter":{"title":"Redux-Toolkit (with_React, Typescript)"}}},"pageContext":{"slug":"/redux-toolkit/"}},"staticQueryHashes":[]}